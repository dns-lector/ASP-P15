ASP.NET
Active Server Pages
Фреймворк .NET призначений для веб-проєктів

Клієнт-серверна технологія
 це технологія, за якою в інформаційному обміні беруть участь дві програми:
 клієнт - той, хто надсилає запит
 сервер - той, хто очікує, приймає та оброблює запит
 у даному сенсі клієнт та сервер - це ролі, що їх грають програми.

Веб-проєкт:
а)
 Сервер (сховище)              Клієнт (браузер)
 HTML+CSS+JS           <---  пише адресу у браузері
  [file(s)]            --->  файли приймаються і виконуються 

б)
 Сервер (активний)              Клієнт (браузер)
  CS (Sharp)           <---  пише адресу у браузері
  формує HTML          --->  дані приймаються (і, можливо, виконуються)

https://localhost:7278/  localhost - спеціальне ім'я, яке показує на даний ПК (петля)
Запит потрапляє до ASP - до маршрутизатора (визначеного у Program.cs)  
   pattern: "{controller=Home}/{action=Index}/{id?}"
згідно з шаблоном, запит розділяється на 3 частини, відокремлені "/"
   controller / action / id
якщо якоїсь частини немає, то береться значення за замовчанням
   базовий запит "/"  -- controller = Home, action = Index, id = null

ASP формує ім'я для контролера з'єднуючи "Home" та "Controller" і шукає відповідний клас
у каталозі "Controllers" - знаходить його, створює з нього об'єкт та
намагається запустити у ньому метод, який відповідає за назвою "action", 
тобто "Index"

Контролер викликає View(), що означає перехід до представлення.
Воно шукається у каталозі Views/[controller]/[action].cshtml
тобто /Views/Home/Index.cshtml
Якщо не знаходить, то намагається шукати у каталозі Shared
тобто /Views/Shared/Index.cshtml

Цей файл "вставляється" до файлу-шаблону представлень
   Views/Shared/_Layout.cshtml
у місце, в якому знаходиться команда 
   @RenderBody()

--------------------------------------------------------------------------

HTTP HyperText Transfer Protocol

Request / Response

Request:

PUT /Home/Index HTTP/1.1            \r\n		| method: GET,POST,PUT,PATCH,DELETE,  HEAD,OPTIONS,TRACE,
Host: mysite.com					\r\n		| Заголовки по схемі
Connection: close					\r\n		| ключ: значення; атрибути
Accept: text/html; charset=utf-8	\r\n		| 
									\r\n		| кінець заголовків - порожній рядок
{"user":"239467923", "new-name":"Petrovich"}	| тіло - до кінця пакету (опціонально). Тіло заборонене для GET та HEAD


Response:

HTTP/1.1  202  Accepted							| 202 - статус-код
Connection: close								| Accepted - Reason Phrase
Content-Type: application/json					| 
												| 
{"server-time": 1876972345}						| 



HTML Forms
методи: GET та POST
спосіб кодування даних (enctype)

 x-www-form-urlencoded: (за замовчанням)
    ключ=значення&ключ2=значення2&...
	дозволяється як GET, так і POST. У запитах GET закодовані дані
	додаються до URL після "?", у випадку POST - у тіло


 multipart/form-data: тільки POST, дозволяє передачу файлів
    Content-Type: text/plain
	Content-Disposition: form-field; name=ключ1

	значення1
	--delimiter------------------
	Content-Type: image/jpeg
	Content-Disposition: form-file; name=file1.jpg

	JPEG11980hvuanw98y3w3urh;kjnavp9792t4rb;kjnv
	----delimiter------------------
---------------------------------------------------------------------------

SUBMIT / AJAX

Form/submit                   Server
<form>
<submit> --------------------> Новий
</form>						   HTML
								 |
Оновлення сторінки <--------------



AJAX (Async Javascript And XML)

<input>
<input>
<button click
        JS fetch ------------> Дані 
							   XML / JSON
        Обробник JS <----------
Протягом обміну даними
сторінка не оновлюється
та зберігає інтерактивність
(відповідає на UI)

--------------------------------------------------------------------------
Кодування - переведення символів однієї абетки у символи іншої абетки
(на відміну від шифрування - без секретів)

Розрізняють символьні та транспортні кодування
Символьні - таблиці код-символ ASCII, UTF-8
Транспортні - для усунення спец. символів, що вживаються у протоколах (?/&": ...)

A          B          C
10101010  10101011  10101100
101010 101010 101110 101100       ABC -> ggY4   base64
   g     g       Y     4

1010 1010 1010 1011 1010 1100
  A   A     A   B     A    C    -> AAABAC       base16 (hex)

----------------------------------------------------------------------------

Middleware - технологія реалізації оброблення даних, що дозволяє додавати
свої обробники "в середину" до інших обробників.

Data -> Processor1 -x-> Processor2 -> ....
             \           /
              MyProcessor

			        Middleware
Request -> Server -|M|--|M|--|M|-> Controller -> Razor(View) 
Response <--    <--|1|--|2|--|3|-------      <------- HTML

Реалізується шляхом реєстрації класів Middleware у Program.cs (Use...)
Порядок реєстрації має значення, бажано свої реєструвати після вбудованих.

Традиції написання Middleware передбачають створення розширень (extensions)
Які також зводять реєстрацію до Use... форми, наприклад, реєстрація
SessionAuthMiddleware мала б виглядати як app.UseSessionAuth()

-----------------------------------------------------------------------------

Авторизація
Задача: передати на весь проєкт інформацію про авторизаційні права / ознаки
користувача.
Просте рішення: покласти до Context.Items якісь дані
 * сам факт авторизації 
    + коротко і зрозуміло
	- немає розділення за ролями / формами допуску
 * Entity user
    + передаються всі дані про користувача
	- прив'язка до Entity, зміна моделі змусить міняти код
 * Уніфікований інтерфейс
    + універсальність
	- потрібно перетворювати наявну модель за інтерфейсом

	                                    Middleware
OAuth FB --> {name, email, fbId}		 |  \  | 
DbAuth   --> {realName, userEmail, id}	 |  -  | --> {Name, Email, Sid}
OAuth GH --> {login, ghId, userName}	 |  /  | 

---------------------------------------------------------------------

API - Application Program Interface

Контролери ASP розрізняють: MVC та API
MVC - різні адреси ведуть на різні дії (actions)
  GET /Home/Index -> Index()
  GET /Home/Db    -> Db()
-----------
 Метод один (GET), адреси різні (/Home/Index, /Home/Db)
 Повертають, частіше за все, HTML (представлення)

   
API - різні методи запиту ведуть на різні дії
  GET  /api/auth  -> DoGet()
  POST /api/auth  -> DoPost()
  PUT  /api/auth  -> DoPut()
-------------
 Одна адреса (/api/auth), методи різні (GET, POST, PUT, DELETE, ...)
 Повертають дані (object / List)


              Backend
            /    |    \     
			   A P I
		 /		 |		\
      Mobile   Desktop   Web

REST - Representation State Transfer
- Сервер не "пам'ятає" історії - кожен запит як новий
  = якщо потрібна авторизація, то запит повинен мати її в собі
- Уніфікована структура запитів та відповідей
  = для усіх запитів однакові "правила", наприклад, локалізація (мова)
     передається параметром "lang" (або заголовком Locale)
  = те ж саме для відповідей, наприклад, кількість даних буде завжди
     у параметрі "count", а кількість об'єктів на одній 
	 сторінці - "per-page"
- реалізація повного переліку дій "CRUD", причому для всіх запитів
    однакові ролі методів, наприклад, POST - завжди створює, а PUT - оновлює

